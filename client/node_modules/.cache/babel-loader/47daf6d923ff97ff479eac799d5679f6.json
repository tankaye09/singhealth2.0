{"ast":null,"code":"/* eslint no-control-regex:0 */\n'use strict';\n\nconst base64 = require('../base64');\n\nconst qp = require('../qp');\n\nconst mimeTypes = require('./mime-types');\n\nmodule.exports = {\n  /**\n   * Checks if a value is plaintext string (uses only printable 7bit chars)\n   *\n   * @param {String} value String to be tested\n   * @returns {Boolean} true if it is a plaintext string\n   */\n  isPlainText(value, isParam) {\n    const re = isParam ? /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\"\\u0080-\\uFFFF]/ : /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/;\n\n    if (typeof value !== 'string' || re.test(value)) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  /**\n   * Checks if a multi line string containes lines longer than the selected value.\n   *\n   * Useful when detecting if a mail message needs any processing at all â€“\n   * if only plaintext characters are used and lines are short, then there is\n   * no need to encode the values in any way. If the value is plaintext but has\n   * longer lines then allowed, then use format=flowed\n   *\n   * @param {Number} lineLength Max line length to check for\n   * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n   */\n  hasLongerLines(str, lineLength) {\n    if (str.length > 128 * 1024) {\n      // do not test strings longer than 128kB\n      return true;\n    }\n\n    return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n  },\n\n  /**\n   * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @return {String} Single or several mime words joined together\n   */\n  encodeWord(data, mimeWordEncoding, maxLength) {\n    mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n    maxLength = maxLength || 0;\n    let encodedStr;\n    let toCharset = 'UTF-8';\n\n    if (maxLength && maxLength > 7 + toCharset.length) {\n      maxLength -= 7 + toCharset.length;\n    }\n\n    if (mimeWordEncoding === 'Q') {\n      // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n      encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\\-/=]/gi, chr => {\n        let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n        if (chr === ' ') {\n          return '_';\n        } else {\n          return '=' + (ord.length === 1 ? '0' + ord : ord);\n        }\n      });\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = typeof data === 'string' ? data : base64.encode(data);\n      maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;\n    }\n\n    if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : base64.encode(data)).length > maxLength) {\n      if (mimeWordEncoding === 'Q') {\n        encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n      } else {\n        // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n        let parts = [];\n        let lpart = '';\n\n        for (let i = 0, len = encodedStr.length; i < len; i++) {\n          let chr = encodedStr.charAt(i); // check if we can add this character to the existing string\n          // without breaking byte length limit\n\n          if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n            lpart += chr;\n          } else {\n            // we hit the length limit, so push the existing string and start over\n            parts.push(base64.encode(lpart));\n            lpart = chr;\n          }\n        }\n\n        if (lpart) {\n          parts.push(base64.encode(lpart));\n        }\n\n        if (parts.length > 1) {\n          encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n        } else {\n          encodedStr = parts.join('');\n        }\n      }\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = base64.encode(data);\n    }\n\n    return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n  },\n\n  /**\n   * Finds word sequences with non ascii text and converts these to mime words\n   *\n   * @param {String} value String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match\n   * @return {String} String with possible mime words\n   */\n  encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {\n    maxLength = maxLength || 0;\n    let encodedValue; // find first word with a non-printable ascii or special symbol in it\n\n    let firstMatch = value.match(/(?:^|\\s)([^\\s]*[\"\\u0080-\\uFFFF])/);\n\n    if (!firstMatch) {\n      return value;\n    }\n\n    if (encodeAll) {\n      // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything\n      return this.encodeWord(value, mimeWordEncoding, maxLength);\n    } // find the last word with a non-printable ascii in it\n\n\n    let lastMatch = value.match(/([\"\\u0080-\\uFFFF][^\\s]*)[^\"\\u0080-\\uFFFF]*$/);\n\n    if (!lastMatch) {\n      // should not happen\n      return value;\n    }\n\n    let startIndex = firstMatch.index + (firstMatch[0].match(/[^\\s]/) || {\n      index: 0\n    }).index;\n    let endIndex = lastMatch.index + (lastMatch[1] || '').length;\n    encodedValue = (startIndex ? value.substr(0, startIndex) : '') + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || 'Q', maxLength) + (endIndex < value.length ? value.substr(endIndex) : '');\n    return encodedValue;\n  },\n\n  /**\n   * Joins parsed header value together as 'value; param1=value1; param2=value2'\n   * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.\n   *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html\n   * @param {Object} structured Parsed header value\n   * @return {String} joined header value\n   */\n  buildHeaderValue(structured) {\n    let paramsArray = [];\n    Object.keys(structured.params || {}).forEach(param => {\n      // filename might include unicode characters so it is a special case\n      // other values probably do not\n      let value = structured.params[param];\n\n      if (!this.isPlainText(value, true) || value.length >= 75) {\n        this.buildHeaderParam(param, value, 50).forEach(encodedParam => {\n          if (!/[\\s\"\\\\;:/=(),<>@[\\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n            paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n          } else {\n            paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n          }\n        });\n      } else if (/[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(value)) {\n        paramsArray.push(param + '=' + JSON.stringify(value));\n      } else {\n        paramsArray.push(param + '=' + value);\n      }\n    });\n    return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n  },\n\n  /**\n   * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n   * Useful for splitting long parameter values.\n   *\n   * For example\n   *      title=\"unicode string\"\n   * becomes\n   *     title*0*=utf-8''unicode\n   *     title*1*=%20string\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {Number} [maxLength=50] Max length for generated chunks\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {Array} A list of encoded keys and headers\n   */\n  buildHeaderParam(key, data, maxLength) {\n    let list = [];\n    let encodedStr = typeof data === 'string' ? data : (data || '').toString();\n    let encodedStrArr;\n    let chr, ord;\n    let line;\n    let startPos = 0;\n    let i, len;\n    maxLength = maxLength || 50; // process ascii only text\n\n    if (this.isPlainText(data, true)) {\n      // check if conversion is even needed\n      if (encodedStr.length <= maxLength) {\n        return [{\n          key,\n          value: encodedStr\n        }];\n      }\n\n      encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), str => {\n        list.push({\n          line: str\n        });\n        return '';\n      });\n\n      if (encodedStr) {\n        list.push({\n          line: encodedStr\n        });\n      }\n    } else {\n      if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n        // string containts surrogate pairs, so normalize it to an array of bytes\n        encodedStrArr = [];\n\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i);\n          ord = chr.charCodeAt(0);\n\n          if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {\n            chr += encodedStr.charAt(i + 1);\n            encodedStrArr.push(chr);\n            i++;\n          } else {\n            encodedStrArr.push(chr);\n          }\n        }\n\n        encodedStr = encodedStrArr;\n      } // first line includes the charset and language info and needs to be encoded\n      // even if it does not contain any unicode characters\n\n\n      line = 'utf-8\\x27\\x27';\n      let encoded = true;\n      startPos = 0; // process text with unicode or special chars\n\n      for (i = 0, len = encodedStr.length; i < len; i++) {\n        chr = encodedStr[i];\n\n        if (encoded) {\n          chr = this.safeEncodeURIComponent(chr);\n        } else {\n          // try to urlencode current char\n          chr = chr === ' ' ? chr : this.safeEncodeURIComponent(chr); // By default it is not required to encode a line, the need\n          // only appears when the string contains unicode or special chars\n          // in this case we start processing the line over and encode all chars\n\n          if (chr !== encodedStr[i]) {\n            // Check if it is even possible to add the encoded char to the line\n            // If not, there is no reason to use this line, just push it to the list\n            // and start a new line with the char that needs encoding\n            if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {\n              list.push({\n                line,\n                encoded\n              });\n              line = '';\n              startPos = i - 1;\n            } else {\n              encoded = true;\n              i = startPos;\n              line = '';\n              continue;\n            }\n          }\n        } // if the line is already too long, push it to the list and start a new one\n\n\n        if ((line + chr).length >= maxLength) {\n          list.push({\n            line,\n            encoded\n          });\n          line = chr = encodedStr[i] === ' ' ? ' ' : this.safeEncodeURIComponent(encodedStr[i]);\n\n          if (chr === encodedStr[i]) {\n            encoded = false;\n            startPos = i - 1;\n          } else {\n            encoded = true;\n          }\n        } else {\n          line += chr;\n        }\n      }\n\n      if (line) {\n        list.push({\n          line,\n          encoded\n        });\n      }\n    }\n\n    return list.map((item, i) => ({\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: item.line\n    }));\n  },\n\n  /**\n   * Parses a header value with key=value arguments into a structured\n   * object.\n   *\n   *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n   *   {\n   *     'value': 'text/plain',\n   *     'params': {\n   *       'charset': 'UTF-8'\n   *     }\n   *   }\n   *\n   * @param {String} str Header value\n   * @return {Object} Header value as a parsed structure\n   */\n  parseHeaderValue(str) {\n    let response = {\n      value: false,\n      params: {}\n    };\n    let key = false;\n    let value = '';\n    let type = 'value';\n    let quote = false;\n    let escaped = false;\n    let chr;\n\n    for (let i = 0, len = str.length; i < len; i++) {\n      chr = str.charAt(i);\n\n      if (type === 'key') {\n        if (chr === '=') {\n          key = value.trim().toLowerCase();\n          type = 'value';\n          value = '';\n          continue;\n        }\n\n        value += chr;\n      } else {\n        if (escaped) {\n          value += chr;\n        } else if (chr === '\\\\') {\n          escaped = true;\n          continue;\n        } else if (quote && chr === quote) {\n          quote = false;\n        } else if (!quote && chr === '\"') {\n          quote = chr;\n        } else if (!quote && chr === ';') {\n          if (key === false) {\n            response.value = value.trim();\n          } else {\n            response.params[key] = value.trim();\n          }\n\n          type = 'key';\n          value = '';\n        } else {\n          value += chr;\n        }\n\n        escaped = false;\n      }\n    }\n\n    if (type === 'value') {\n      if (key === false) {\n        response.value = value.trim();\n      } else {\n        response.params[key] = value.trim();\n      }\n    } else if (value.trim()) {\n      response.params[value.trim().toLowerCase()] = '';\n    } // handle parameter value continuations\n    // https://tools.ietf.org/html/rfc2231#section-3\n    // preprocess values\n\n\n    Object.keys(response.params).forEach(key => {\n      let actualKey, nr, match, value;\n\n      if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n        actualKey = key.substr(0, match.index);\n        nr = Number(match[2] || match[3]) || 0;\n\n        if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n          response.params[actualKey] = {\n            charset: false,\n            values: []\n          };\n        }\n\n        value = response.params[key];\n\n        if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n          response.params[actualKey].charset = match[1] || 'iso-8859-1';\n          value = match[2];\n        }\n\n        response.params[actualKey].values[nr] = value; // remove the old reference\n\n        delete response.params[key];\n      }\n    }); // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n\n    Object.keys(response.params).forEach(key => {\n      let value;\n\n      if (response.params[key] && Array.isArray(response.params[key].values)) {\n        value = response.params[key].values.map(val => val || '').join('');\n\n        if (response.params[key].charset) {\n          // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n          response.params[key] = '=?' + response.params[key].charset + '?Q?' + value // fix invalidly encoded chars\n          .replace(/[=?_\\s]/g, s => {\n            let c = s.charCodeAt(0).toString(16);\n\n            if (s === ' ') {\n              return '_';\n            } else {\n              return '%' + (c.length < 2 ? '0' : '') + c;\n            }\n          }) // change from urlencoding to percent encoding\n          .replace(/%/g, '=') + '?=';\n        } else {\n          response.params[key] = value;\n        }\n      }\n    });\n    return response;\n  },\n\n  /**\n   * Returns file extension for a content type string. If no suitable extensions\n   * are found, 'bin' is used as the default extension\n   *\n   * @param {String} mimeType Content type to be checked for\n   * @return {String} File extension\n   */\n  detectExtension: mimeType => mimeTypes.detectExtension(mimeType),\n\n  /**\n   * Returns content type for a file extension. If no suitable content types\n   * are found, 'application/octet-stream' is used as the default content type\n   *\n   * @param {String} extension Extension to be checked for\n   * @return {String} File extension\n   */\n  detectMimeType: extension => mimeTypes.detectMimeType(extension),\n\n  /**\n   * Folds long lines, useful for folding header lines (afterSpace=false) and\n   * flowed text (afterSpace=true)\n   *\n   * @param {String} str String to be folded\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @param {Boolean} afterSpace If true, leave a space in th end of a line\n   * @return {String} String with folded lines\n   */\n  foldLines(str, lineLength, afterSpace) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n    let pos = 0,\n        len = str.length,\n        result = '',\n        line,\n        match;\n\n    while (pos < len) {\n      line = str.substr(pos, lineLength);\n\n      if (line.length < lineLength) {\n        result += line;\n        break;\n      }\n\n      if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n        line = match[0];\n        result += line;\n        pos += line.length;\n        continue;\n      } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n        line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n      } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n        line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n      }\n\n      result += line;\n      pos += line.length;\n\n      if (pos < len) {\n        result += '\\r\\n';\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n   *\n   * @param {String} str Mime encoded string to be split up\n   * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n   * @return {Array} Split string\n   */\n  splitMimeEncodedString: (str, maxlen) => {\n    let curLine,\n        match,\n        chr,\n        done,\n        lines = []; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n    maxlen = Math.max(maxlen || 0, 12);\n\n    while (str.length) {\n      curLine = str.substr(0, maxlen); // move incomplete escaped char back to main\n\n      if (match = curLine.match(/[=][0-9A-F]?$/i)) {\n        curLine = curLine.substr(0, match.index);\n      }\n\n      done = false;\n\n      while (!done) {\n        done = true; // check if not middle of a unicode char sequence\n\n        if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {\n          chr = parseInt(match[1], 16); // invalid sequence, move one char back anc recheck\n\n          if (chr < 0xc2 && chr > 0x7f) {\n            curLine = curLine.substr(0, curLine.length - 3);\n            done = false;\n          }\n        }\n      }\n\n      if (curLine.length) {\n        lines.push(curLine);\n      }\n\n      str = str.substr(curLine.length);\n    }\n\n    return lines;\n  },\n  encodeURICharComponent: chr => {\n    let res = '';\n    let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n    if (ord.length % 2) {\n      ord = '0' + ord;\n    }\n\n    if (ord.length > 2) {\n      for (let i = 0, len = ord.length / 2; i < len; i++) {\n        res += '%' + ord.substr(i, 2);\n      }\n    } else {\n      res += '%' + ord;\n    }\n\n    return res;\n  },\n\n  safeEncodeURIComponent(str) {\n    str = (str || '').toString();\n\n    try {\n      // might throw if we try to encode invalid sequences, eg. partial emoji\n      str = encodeURIComponent(str);\n    } catch (E) {\n      // should never run\n      return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]+/g, '');\n    } // ensure chars that are not handled by encodeURICompent are converted as well\n\n\n    return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]/g, chr => this.encodeURICharComponent(chr));\n  }\n\n};","map":{"version":3,"sources":["C:/Users/tanka/Desktop/ESC/Project/SingHealthApp/singhealth2.0/node_modules/nodemailer/lib/mime-funcs/index.js"],"names":["base64","require","qp","mimeTypes","module","exports","isPlainText","value","isParam","re","test","hasLongerLines","str","lineLength","length","RegExp","encodeWord","data","mimeWordEncoding","maxLength","toString","toUpperCase","trim","charAt","encodedStr","toCharset","encode","replace","chr","ord","charCodeAt","Math","max","splitMimeEncodedString","join","parts","lpart","i","len","Buffer","byteLength","push","substr","encodeWords","encodeAll","encodedValue","firstMatch","match","lastMatch","startIndex","index","endIndex","substring","buildHeaderValue","structured","paramsArray","Object","keys","params","forEach","param","buildHeaderParam","encodedParam","key","JSON","stringify","list","encodedStrArr","line","startPos","encoded","safeEncodeURIComponent","map","item","parseHeaderValue","response","type","quote","escaped","toLowerCase","actualKey","nr","Number","charset","values","Array","isArray","val","s","c","detectExtension","mimeType","detectMimeType","extension","foldLines","afterSpace","pos","result","maxlen","curLine","done","lines","parseInt","encodeURICharComponent","res","encodeURIComponent","E"],"mappings":"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","sourcesContent":["/* eslint no-control-regex:0 */\n\n'use strict';\n\nconst base64 = require('../base64');\nconst qp = require('../qp');\nconst mimeTypes = require('./mime-types');\n\nmodule.exports = {\n    /**\n     * Checks if a value is plaintext string (uses only printable 7bit chars)\n     *\n     * @param {String} value String to be tested\n     * @returns {Boolean} true if it is a plaintext string\n     */\n    isPlainText(value, isParam) {\n        const re = isParam ? /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\"\\u0080-\\uFFFF]/ : /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/;\n        if (typeof value !== 'string' || re.test(value)) {\n            return false;\n        } else {\n            return true;\n        }\n    },\n\n    /**\n     * Checks if a multi line string containes lines longer than the selected value.\n     *\n     * Useful when detecting if a mail message needs any processing at all â€“\n     * if only plaintext characters are used and lines are short, then there is\n     * no need to encode the values in any way. If the value is plaintext but has\n     * longer lines then allowed, then use format=flowed\n     *\n     * @param {Number} lineLength Max line length to check for\n     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n     */\n    hasLongerLines(str, lineLength) {\n        if (str.length > 128 * 1024) {\n            // do not test strings longer than 128kB\n            return true;\n        }\n        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @return {String} Single or several mime words joined together\n     */\n    encodeWord(data, mimeWordEncoding, maxLength) {\n        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n        maxLength = maxLength || 0;\n\n        let encodedStr;\n        let toCharset = 'UTF-8';\n\n        if (maxLength && maxLength > 7 + toCharset.length) {\n            maxLength -= 7 + toCharset.length;\n        }\n\n        if (mimeWordEncoding === 'Q') {\n            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n            encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\\-/=]/gi, chr => {\n                let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n                if (chr === ' ') {\n                    return '_';\n                } else {\n                    return '=' + (ord.length === 1 ? '0' + ord : ord);\n                }\n            });\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = typeof data === 'string' ? data : base64.encode(data);\n            maxLength = maxLength ? Math.max(3, ((maxLength - (maxLength % 4)) / 4) * 3) : 0;\n        }\n\n        if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : base64.encode(data)).length > maxLength) {\n            if (mimeWordEncoding === 'Q') {\n                encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n            } else {\n                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n                let parts = [];\n                let lpart = '';\n                for (let i = 0, len = encodedStr.length; i < len; i++) {\n                    let chr = encodedStr.charAt(i);\n                    // check if we can add this character to the existing string\n                    // without breaking byte length limit\n                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n                        lpart += chr;\n                    } else {\n                        // we hit the length limit, so push the existing string and start over\n                        parts.push(base64.encode(lpart));\n                        lpart = chr;\n                    }\n                }\n                if (lpart) {\n                    parts.push(base64.encode(lpart));\n                }\n\n                if (parts.length > 1) {\n                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n                } else {\n                    encodedStr = parts.join('');\n                }\n            }\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = base64.encode(data);\n        }\n\n        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n    },\n\n    /**\n     * Finds word sequences with non ascii text and converts these to mime words\n     *\n     * @param {String} value String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match\n     * @return {String} String with possible mime words\n     */\n    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {\n        maxLength = maxLength || 0;\n\n        let encodedValue;\n\n        // find first word with a non-printable ascii or special symbol in it\n        let firstMatch = value.match(/(?:^|\\s)([^\\s]*[\"\\u0080-\\uFFFF])/);\n        if (!firstMatch) {\n            return value;\n        }\n\n        if (encodeAll) {\n            // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything\n\n            return this.encodeWord(value, mimeWordEncoding, maxLength);\n        }\n\n        // find the last word with a non-printable ascii in it\n        let lastMatch = value.match(/([\"\\u0080-\\uFFFF][^\\s]*)[^\"\\u0080-\\uFFFF]*$/);\n        if (!lastMatch) {\n            // should not happen\n            return value;\n        }\n\n        let startIndex =\n            firstMatch.index +\n            (\n                firstMatch[0].match(/[^\\s]/) || {\n                    index: 0\n                }\n            ).index;\n        let endIndex = lastMatch.index + (lastMatch[1] || '').length;\n\n        encodedValue =\n            (startIndex ? value.substr(0, startIndex) : '') +\n            this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || 'Q', maxLength) +\n            (endIndex < value.length ? value.substr(endIndex) : '');\n\n        return encodedValue;\n    },\n\n    /**\n     * Joins parsed header value together as 'value; param1=value1; param2=value2'\n     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.\n     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html\n     * @param {Object} structured Parsed header value\n     * @return {String} joined header value\n     */\n    buildHeaderValue(structured) {\n        let paramsArray = [];\n\n        Object.keys(structured.params || {}).forEach(param => {\n            // filename might include unicode characters so it is a special case\n            // other values probably do not\n            let value = structured.params[param];\n            if (!this.isPlainText(value, true) || value.length >= 75) {\n                this.buildHeaderParam(param, value, 50).forEach(encodedParam => {\n                    if (!/[\\s\"\\\\;:/=(),<>@[\\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n                    } else {\n                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n                    }\n                });\n            } else if (/[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(value)) {\n                paramsArray.push(param + '=' + JSON.stringify(value));\n            } else {\n                paramsArray.push(param + '=' + value);\n            }\n        });\n\n        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n     * Useful for splitting long parameter values.\n     *\n     * For example\n     *      title=\"unicode string\"\n     * becomes\n     *     title*0*=utf-8''unicode\n     *     title*1*=%20string\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {Number} [maxLength=50] Max length for generated chunks\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {Array} A list of encoded keys and headers\n     */\n    buildHeaderParam(key, data, maxLength) {\n        let list = [];\n        let encodedStr = typeof data === 'string' ? data : (data || '').toString();\n        let encodedStrArr;\n        let chr, ord;\n        let line;\n        let startPos = 0;\n        let i, len;\n\n        maxLength = maxLength || 50;\n\n        // process ascii only text\n        if (this.isPlainText(data, true)) {\n            // check if conversion is even needed\n            if (encodedStr.length <= maxLength) {\n                return [\n                    {\n                        key,\n                        value: encodedStr\n                    }\n                ];\n            }\n\n            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), str => {\n                list.push({\n                    line: str\n                });\n                return '';\n            });\n\n            if (encodedStr) {\n                list.push({\n                    line: encodedStr\n                });\n            }\n        } else {\n            if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n                // string containts surrogate pairs, so normalize it to an array of bytes\n                encodedStrArr = [];\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    ord = chr.charCodeAt(0);\n                    if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {\n                        chr += encodedStr.charAt(i + 1);\n                        encodedStrArr.push(chr);\n                        i++;\n                    } else {\n                        encodedStrArr.push(chr);\n                    }\n                }\n                encodedStr = encodedStrArr;\n            }\n\n            // first line includes the charset and language info and needs to be encoded\n            // even if it does not contain any unicode characters\n            line = 'utf-8\\x27\\x27';\n            let encoded = true;\n            startPos = 0;\n\n            // process text with unicode or special chars\n            for (i = 0, len = encodedStr.length; i < len; i++) {\n                chr = encodedStr[i];\n\n                if (encoded) {\n                    chr = this.safeEncodeURIComponent(chr);\n                } else {\n                    // try to urlencode current char\n                    chr = chr === ' ' ? chr : this.safeEncodeURIComponent(chr);\n                    // By default it is not required to encode a line, the need\n                    // only appears when the string contains unicode or special chars\n                    // in this case we start processing the line over and encode all chars\n                    if (chr !== encodedStr[i]) {\n                        // Check if it is even possible to add the encoded char to the line\n                        // If not, there is no reason to use this line, just push it to the list\n                        // and start a new line with the char that needs encoding\n                        if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {\n                            list.push({\n                                line,\n                                encoded\n                            });\n                            line = '';\n                            startPos = i - 1;\n                        } else {\n                            encoded = true;\n                            i = startPos;\n                            line = '';\n                            continue;\n                        }\n                    }\n                }\n\n                // if the line is already too long, push it to the list and start a new one\n                if ((line + chr).length >= maxLength) {\n                    list.push({\n                        line,\n                        encoded\n                    });\n                    line = chr = encodedStr[i] === ' ' ? ' ' : this.safeEncodeURIComponent(encodedStr[i]);\n                    if (chr === encodedStr[i]) {\n                        encoded = false;\n                        startPos = i - 1;\n                    } else {\n                        encoded = true;\n                    }\n                } else {\n                    line += chr;\n                }\n            }\n\n            if (line) {\n                list.push({\n                    line,\n                    encoded\n                });\n            }\n        }\n\n        return list.map((item, i) => ({\n            // encoded lines: {name}*{part}*\n            // unencoded lines: {name}*{part}\n            // if any line needs to be encoded then the first line (part==0) is always encoded\n            key: key + '*' + i + (item.encoded ? '*' : ''),\n            value: item.line\n        }));\n    },\n\n    /**\n     * Parses a header value with key=value arguments into a structured\n     * object.\n     *\n     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n     *   {\n     *     'value': 'text/plain',\n     *     'params': {\n     *       'charset': 'UTF-8'\n     *     }\n     *   }\n     *\n     * @param {String} str Header value\n     * @return {Object} Header value as a parsed structure\n     */\n    parseHeaderValue(str) {\n        let response = {\n            value: false,\n            params: {}\n        };\n        let key = false;\n        let value = '';\n        let type = 'value';\n        let quote = false;\n        let escaped = false;\n        let chr;\n\n        for (let i = 0, len = str.length; i < len; i++) {\n            chr = str.charAt(i);\n            if (type === 'key') {\n                if (chr === '=') {\n                    key = value.trim().toLowerCase();\n                    type = 'value';\n                    value = '';\n                    continue;\n                }\n                value += chr;\n            } else {\n                if (escaped) {\n                    value += chr;\n                } else if (chr === '\\\\') {\n                    escaped = true;\n                    continue;\n                } else if (quote && chr === quote) {\n                    quote = false;\n                } else if (!quote && chr === '\"') {\n                    quote = chr;\n                } else if (!quote && chr === ';') {\n                    if (key === false) {\n                        response.value = value.trim();\n                    } else {\n                        response.params[key] = value.trim();\n                    }\n                    type = 'key';\n                    value = '';\n                } else {\n                    value += chr;\n                }\n                escaped = false;\n            }\n        }\n\n        if (type === 'value') {\n            if (key === false) {\n                response.value = value.trim();\n            } else {\n                response.params[key] = value.trim();\n            }\n        } else if (value.trim()) {\n            response.params[value.trim().toLowerCase()] = '';\n        }\n\n        // handle parameter value continuations\n        // https://tools.ietf.org/html/rfc2231#section-3\n\n        // preprocess values\n        Object.keys(response.params).forEach(key => {\n            let actualKey, nr, match, value;\n            if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n                actualKey = key.substr(0, match.index);\n                nr = Number(match[2] || match[3]) || 0;\n\n                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n                    response.params[actualKey] = {\n                        charset: false,\n                        values: []\n                    };\n                }\n\n                value = response.params[key];\n\n                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n                    response.params[actualKey].charset = match[1] || 'iso-8859-1';\n                    value = match[2];\n                }\n\n                response.params[actualKey].values[nr] = value;\n\n                // remove the old reference\n                delete response.params[key];\n            }\n        });\n\n        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n        Object.keys(response.params).forEach(key => {\n            let value;\n            if (response.params[key] && Array.isArray(response.params[key].values)) {\n                value = response.params[key].values.map(val => val || '').join('');\n\n                if (response.params[key].charset) {\n                    // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n                    response.params[key] =\n                        '=?' +\n                        response.params[key].charset +\n                        '?Q?' +\n                        value\n                            // fix invalidly encoded chars\n                            .replace(/[=?_\\s]/g, s => {\n                                let c = s.charCodeAt(0).toString(16);\n                                if (s === ' ') {\n                                    return '_';\n                                } else {\n                                    return '%' + (c.length < 2 ? '0' : '') + c;\n                                }\n                            })\n                            // change from urlencoding to percent encoding\n                            .replace(/%/g, '=') +\n                        '?=';\n                } else {\n                    response.params[key] = value;\n                }\n            }\n        });\n\n        return response;\n    },\n\n    /**\n     * Returns file extension for a content type string. If no suitable extensions\n     * are found, 'bin' is used as the default extension\n     *\n     * @param {String} mimeType Content type to be checked for\n     * @return {String} File extension\n     */\n    detectExtension: mimeType => mimeTypes.detectExtension(mimeType),\n\n    /**\n     * Returns content type for a file extension. If no suitable content types\n     * are found, 'application/octet-stream' is used as the default content type\n     *\n     * @param {String} extension Extension to be checked for\n     * @return {String} File extension\n     */\n    detectMimeType: extension => mimeTypes.detectMimeType(extension),\n\n    /**\n     * Folds long lines, useful for folding header lines (afterSpace=false) and\n     * flowed text (afterSpace=true)\n     *\n     * @param {String} str String to be folded\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @param {Boolean} afterSpace If true, leave a space in th end of a line\n     * @return {String} String with folded lines\n     */\n    foldLines(str, lineLength, afterSpace) {\n        str = (str || '').toString();\n        lineLength = lineLength || 76;\n\n        let pos = 0,\n            len = str.length,\n            result = '',\n            line,\n            match;\n\n        while (pos < len) {\n            line = str.substr(pos, lineLength);\n            if (line.length < lineLength) {\n                result += line;\n                break;\n            }\n            if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n                line = match[0];\n                result += line;\n                pos += line.length;\n                continue;\n            } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n            } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n            }\n\n            result += line;\n            pos += line.length;\n            if (pos < len) {\n                result += '\\r\\n';\n            }\n        }\n\n        return result;\n    },\n\n    /**\n     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n     *\n     * @param {String} str Mime encoded string to be split up\n     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n     * @return {Array} Split string\n     */\n    splitMimeEncodedString: (str, maxlen) => {\n        let curLine,\n            match,\n            chr,\n            done,\n            lines = [];\n\n        // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n        maxlen = Math.max(maxlen || 0, 12);\n\n        while (str.length) {\n            curLine = str.substr(0, maxlen);\n\n            // move incomplete escaped char back to main\n            if ((match = curLine.match(/[=][0-9A-F]?$/i))) {\n                curLine = curLine.substr(0, match.index);\n            }\n\n            done = false;\n            while (!done) {\n                done = true;\n                // check if not middle of a unicode char sequence\n                if ((match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i))) {\n                    chr = parseInt(match[1], 16);\n                    // invalid sequence, move one char back anc recheck\n                    if (chr < 0xc2 && chr > 0x7f) {\n                        curLine = curLine.substr(0, curLine.length - 3);\n                        done = false;\n                    }\n                }\n            }\n\n            if (curLine.length) {\n                lines.push(curLine);\n            }\n            str = str.substr(curLine.length);\n        }\n\n        return lines;\n    },\n\n    encodeURICharComponent: chr => {\n        let res = '';\n        let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n        if (ord.length % 2) {\n            ord = '0' + ord;\n        }\n\n        if (ord.length > 2) {\n            for (let i = 0, len = ord.length / 2; i < len; i++) {\n                res += '%' + ord.substr(i, 2);\n            }\n        } else {\n            res += '%' + ord;\n        }\n\n        return res;\n    },\n\n    safeEncodeURIComponent(str) {\n        str = (str || '').toString();\n\n        try {\n            // might throw if we try to encode invalid sequences, eg. partial emoji\n            str = encodeURIComponent(str);\n        } catch (E) {\n            // should never run\n            return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]+/g, '');\n        }\n\n        // ensure chars that are not handled by encodeURICompent are converted as well\n        return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]/g, chr => this.encodeURICharComponent(chr));\n    }\n};\n"]},"metadata":{},"sourceType":"script"}