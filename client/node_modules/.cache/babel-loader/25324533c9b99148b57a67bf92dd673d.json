{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst Transform = stream.Transform;\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\n\nclass DataStream extends Transform {\n  constructor(options) {\n    super(options); // init Transform\n\n    this.options = options || {};\n    this._curLine = '';\n    this.inByteCount = 0;\n    this.outByteCount = 0;\n    this.lastByte = false;\n  }\n  /**\n   * Escapes dots\n   */\n\n\n  _transform(chunk, encoding, done) {\n    let chunks = [];\n    let chunklen = 0;\n    let i,\n        len,\n        lastPos = 0;\n    let buf;\n\n    if (!chunk || !chunk.length) {\n      return done();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk);\n    }\n\n    this.inByteCount += chunk.length;\n\n    for (i = 0, len = chunk.length; i < len; i++) {\n      if (chunk[i] === 0x2e) {\n        // .\n        if (i && chunk[i - 1] === 0x0a || !i && (!this.lastByte || this.lastByte === 0x0a)) {\n          buf = chunk.slice(lastPos, i + 1);\n          chunks.push(buf);\n          chunks.push(Buffer.from('.'));\n          chunklen += buf.length + 1;\n          lastPos = i + 1;\n        }\n      } else if (chunk[i] === 0x0a) {\n        // .\n        if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {\n          if (i > lastPos) {\n            buf = chunk.slice(lastPos, i);\n            chunks.push(buf);\n            chunklen += buf.length + 2;\n          } else {\n            chunklen += 2;\n          }\n\n          chunks.push(Buffer.from('\\r\\n'));\n          lastPos = i + 1;\n        }\n      }\n    }\n\n    if (chunklen) {\n      // add last piece\n      if (lastPos < chunk.length) {\n        buf = chunk.slice(lastPos);\n        chunks.push(buf);\n        chunklen += buf.length;\n      }\n\n      this.outByteCount += chunklen;\n      this.push(Buffer.concat(chunks, chunklen));\n    } else {\n      this.outByteCount += chunk.length;\n      this.push(chunk);\n    }\n\n    this.lastByte = chunk[chunk.length - 1];\n    done();\n  }\n  /**\n   * Finalizes the stream with a dot on a single line\n   */\n\n\n  _flush(done) {\n    let buf;\n\n    if (this.lastByte === 0x0a) {\n      buf = Buffer.from('.\\r\\n');\n    } else if (this.lastByte === 0x0d) {\n      buf = Buffer.from('\\n.\\r\\n');\n    } else {\n      buf = Buffer.from('\\r\\n.\\r\\n');\n    }\n\n    this.outByteCount += buf.length;\n    this.push(buf);\n    done();\n  }\n\n}\n\nmodule.exports = DataStream;","map":{"version":3,"sources":["C:/Users/tanka/Desktop/ESC/Project/SingHealthApp/singhealth2.0/node_modules/nodemailer/lib/smtp-connection/data-stream.js"],"names":["stream","require","Transform","DataStream","constructor","options","_curLine","inByteCount","outByteCount","lastByte","_transform","chunk","encoding","done","chunks","chunklen","i","len","lastPos","buf","length","Buffer","from","slice","push","concat","_flush","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this._curLine = '';\n\n        this.inByteCount = 0;\n        this.outByteCount = 0;\n        this.lastByte = false;\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let chunks = [];\n        let chunklen = 0;\n        let i,\n            len,\n            lastPos = 0;\n        let buf;\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk);\n        }\n\n        this.inByteCount += chunk.length;\n\n        for (i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x2e) {\n                // .\n                if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {\n                    buf = chunk.slice(lastPos, i + 1);\n                    chunks.push(buf);\n                    chunks.push(Buffer.from('.'));\n                    chunklen += buf.length + 1;\n                    lastPos = i + 1;\n                }\n            } else if (chunk[i] === 0x0a) {\n                // .\n                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        chunks.push(buf);\n                        chunklen += buf.length + 2;\n                    } else {\n                        chunklen += 2;\n                    }\n                    chunks.push(Buffer.from('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (chunklen) {\n            // add last piece\n            if (lastPos < chunk.length) {\n                buf = chunk.slice(lastPos);\n                chunks.push(buf);\n                chunklen += buf.length;\n            }\n\n            this.outByteCount += chunklen;\n            this.push(Buffer.concat(chunks, chunklen));\n        } else {\n            this.outByteCount += chunk.length;\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n    _flush(done) {\n        let buf;\n        if (this.lastByte === 0x0a) {\n            buf = Buffer.from('.\\r\\n');\n        } else if (this.lastByte === 0x0d) {\n            buf = Buffer.from('\\n.\\r\\n');\n        } else {\n            buf = Buffer.from('\\r\\n.\\r\\n');\n        }\n        this.outByteCount += buf.length;\n        this.push(buf);\n        done();\n    }\n}\n\nmodule.exports = DataStream;\n"]},"metadata":{},"sourceType":"script"}