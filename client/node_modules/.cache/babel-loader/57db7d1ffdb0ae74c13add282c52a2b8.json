{"ast":null,"code":"'use strict'; // module to handle cookies\n\nconst urllib = require('url');\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\n\nclass Cookies {\n  constructor(options) {\n    this.options = options || {};\n    this.cookies = [];\n  }\n  /**\n   * Stores a cookie string to the cookie storage\n   *\n   * @param {String} cookieStr Value from the 'Set-Cookie:' header\n   * @param {String} url Current URL\n   */\n\n\n  set(cookieStr, url) {\n    let urlparts = urllib.parse(url || '');\n    let cookie = this.parse(cookieStr);\n    let domain;\n\n    if (cookie.domain) {\n      domain = cookie.domain.replace(/^\\./, ''); // do not allow cross origin cookies\n\n      if ( // can't be valid if the requested domain is shorter than current hostname\n      urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used\n      ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain) {\n        cookie.domain = urlparts.hostname;\n      }\n    } else {\n      cookie.domain = urlparts.hostname;\n    }\n\n    if (!cookie.path) {\n      cookie.path = this.getPath(urlparts.pathname);\n    } // if no expire date, then use sessionTimeout value\n\n\n    if (!cookie.expires) {\n      cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n    }\n\n    return this.add(cookie);\n  }\n  /**\n   * Returns cookie string for the 'Cookie:' header.\n   *\n   * @param {String} url URL to check for\n   * @returns {String} Cookie header or empty string if no matches were found\n   */\n\n\n  get(url) {\n    return this.list(url).map(cookie => cookie.name + '=' + cookie.value).join('; ');\n  }\n  /**\n   * Lists all valied cookie objects for the specified URL\n   *\n   * @param {String} url URL to check for\n   * @returns {Array} An array of cookie objects\n   */\n\n\n  list(url) {\n    let result = [];\n    let i;\n    let cookie;\n\n    for (i = this.cookies.length - 1; i >= 0; i--) {\n      cookie = this.cookies[i];\n\n      if (this.isExpired(cookie)) {\n        this.cookies.splice(i, i);\n        continue;\n      }\n\n      if (this.match(cookie, url)) {\n        result.unshift(cookie);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Parses cookie string from the 'Set-Cookie:' header\n   *\n   * @param {String} cookieStr String from the 'Set-Cookie:' header\n   * @returns {Object} Cookie object\n   */\n\n\n  parse(cookieStr) {\n    let cookie = {};\n    (cookieStr || '').toString().split(';').forEach(cookiePart => {\n      let valueParts = cookiePart.split('=');\n      let key = valueParts.shift().trim().toLowerCase();\n      let value = valueParts.join('=').trim();\n      let domain;\n\n      if (!key) {\n        // skip empty parts\n        return;\n      }\n\n      switch (key) {\n        case 'expires':\n          value = new Date(value); // ignore date if can not parse it\n\n          if (value.toString() !== 'Invalid Date') {\n            cookie.expires = value;\n          }\n\n          break;\n\n        case 'path':\n          cookie.path = value;\n          break;\n\n        case 'domain':\n          domain = value.toLowerCase();\n\n          if (domain.length && domain.charAt(0) !== '.') {\n            domain = '.' + domain; // ensure preceeding dot for user set domains\n          }\n\n          cookie.domain = domain;\n          break;\n\n        case 'max-age':\n          cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n          break;\n\n        case 'secure':\n          cookie.secure = true;\n          break;\n\n        case 'httponly':\n          cookie.httponly = true;\n          break;\n\n        default:\n          if (!cookie.name) {\n            cookie.name = key;\n            cookie.value = value;\n          }\n\n      }\n    });\n    return cookie;\n  }\n  /**\n   * Checks if a cookie object is valid for a specified URL\n   *\n   * @param {Object} cookie Cookie object\n   * @param {String} url URL to check for\n   * @returns {Boolean} true if cookie is valid for specifiec URL\n   */\n\n\n  match(cookie, url) {\n    let urlparts = urllib.parse(url || ''); // check if hostname matches\n    // .foo.com also matches subdomains, foo.com does not\n\n    if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {\n      return false;\n    } // check if path matches\n\n\n    let path = this.getPath(urlparts.pathname);\n\n    if (path.substr(0, cookie.path.length) !== cookie.path) {\n      return false;\n    } // check secure argument\n\n\n    if (cookie.secure && urlparts.protocol !== 'https:') {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Adds (or updates/removes if needed) a cookie object to the cookie storage\n   *\n   * @param {Object} cookie Cookie value to be stored\n   */\n\n\n  add(cookie) {\n    let i;\n    let len; // nothing to do here\n\n    if (!cookie || !cookie.name) {\n      return false;\n    } // overwrite if has same params\n\n\n    for (i = 0, len = this.cookies.length; i < len; i++) {\n      if (this.compare(this.cookies[i], cookie)) {\n        // check if the cookie needs to be removed instead\n        if (this.isExpired(cookie)) {\n          this.cookies.splice(i, 1); // remove expired/unset cookie\n\n          return false;\n        }\n\n        this.cookies[i] = cookie;\n        return true;\n      }\n    } // add as new if not already expired\n\n\n    if (!this.isExpired(cookie)) {\n      this.cookies.push(cookie);\n    }\n\n    return true;\n  }\n  /**\n   * Checks if two cookie objects are the same\n   *\n   * @param {Object} a Cookie to check against\n   * @param {Object} b Cookie to check against\n   * @returns {Boolean} True, if the cookies are the same\n   */\n\n\n  compare(a, b) {\n    return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n  }\n  /**\n   * Checks if a cookie is expired\n   *\n   * @param {Object} cookie Cookie object to check against\n   * @returns {Boolean} True, if the cookie is expired\n   */\n\n\n  isExpired(cookie) {\n    return cookie.expires && cookie.expires < new Date() || !cookie.value;\n  }\n  /**\n   * Returns normalized cookie path for an URL path argument\n   *\n   * @param {String} pathname\n   * @returns {String} Normalized path\n   */\n\n\n  getPath(pathname) {\n    let path = (pathname || '/').split('/');\n    path.pop(); // remove filename part\n\n    path = path.join('/').trim(); // ensure path prefix /\n\n    if (path.charAt(0) !== '/') {\n      path = '/' + path;\n    } // ensure path suffix /\n\n\n    if (path.substr(-1) !== '/') {\n      path += '/';\n    }\n\n    return path;\n  }\n\n}\n\nmodule.exports = Cookies;","map":{"version":3,"sources":["C:/Users/tanka/Desktop/ESC/Project/SingHealthApp/singhealth2.0/node_modules/nodemailer/lib/fetch/cookies.js"],"names":["urllib","require","SESSION_TIMEOUT","Cookies","constructor","options","cookies","set","cookieStr","url","urlparts","parse","cookie","domain","replace","hostname","length","substr","path","getPath","pathname","expires","Date","now","Number","sessionTimeout","add","get","list","map","name","value","join","result","i","isExpired","splice","match","unshift","toString","split","forEach","cookiePart","valueParts","key","shift","trim","toLowerCase","charAt","secure","httponly","protocol","len","compare","push","a","b","pop","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// module to handle cookies\n\nconst urllib = require('url');\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nclass Cookies {\n    constructor(options) {\n        this.options = options || {};\n        this.cookies = [];\n    }\n\n    /**\n     * Stores a cookie string to the cookie storage\n     *\n     * @param {String} cookieStr Value from the 'Set-Cookie:' header\n     * @param {String} url Current URL\n     */\n    set(cookieStr, url) {\n        let urlparts = urllib.parse(url || '');\n        let cookie = this.parse(cookieStr);\n        let domain;\n\n        if (cookie.domain) {\n            domain = cookie.domain.replace(/^\\./, '');\n\n            // do not allow cross origin cookies\n            if (\n                // can't be valid if the requested domain is shorter than current hostname\n                urlparts.hostname.length < domain.length ||\n                // prefix domains with dot to be sure that partial matches are not used\n                ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain\n            ) {\n                cookie.domain = urlparts.hostname;\n            }\n        } else {\n            cookie.domain = urlparts.hostname;\n        }\n\n        if (!cookie.path) {\n            cookie.path = this.getPath(urlparts.pathname);\n        }\n\n        // if no expire date, then use sessionTimeout value\n        if (!cookie.expires) {\n            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n        }\n\n        return this.add(cookie);\n    }\n\n    /**\n     * Returns cookie string for the 'Cookie:' header.\n     *\n     * @param {String} url URL to check for\n     * @returns {String} Cookie header or empty string if no matches were found\n     */\n    get(url) {\n        return this.list(url)\n            .map(cookie => cookie.name + '=' + cookie.value)\n            .join('; ');\n    }\n\n    /**\n     * Lists all valied cookie objects for the specified URL\n     *\n     * @param {String} url URL to check for\n     * @returns {Array} An array of cookie objects\n     */\n    list(url) {\n        let result = [];\n        let i;\n        let cookie;\n\n        for (i = this.cookies.length - 1; i >= 0; i--) {\n            cookie = this.cookies[i];\n\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, i);\n                continue;\n            }\n\n            if (this.match(cookie, url)) {\n                result.unshift(cookie);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Parses cookie string from the 'Set-Cookie:' header\n     *\n     * @param {String} cookieStr String from the 'Set-Cookie:' header\n     * @returns {Object} Cookie object\n     */\n    parse(cookieStr) {\n        let cookie = {};\n\n        (cookieStr || '')\n            .toString()\n            .split(';')\n            .forEach(cookiePart => {\n                let valueParts = cookiePart.split('=');\n                let key = valueParts.shift().trim().toLowerCase();\n                let value = valueParts.join('=').trim();\n                let domain;\n\n                if (!key) {\n                    // skip empty parts\n                    return;\n                }\n\n                switch (key) {\n                    case 'expires':\n                        value = new Date(value);\n                        // ignore date if can not parse it\n                        if (value.toString() !== 'Invalid Date') {\n                            cookie.expires = value;\n                        }\n                        break;\n\n                    case 'path':\n                        cookie.path = value;\n                        break;\n\n                    case 'domain':\n                        domain = value.toLowerCase();\n                        if (domain.length && domain.charAt(0) !== '.') {\n                            domain = '.' + domain; // ensure preceeding dot for user set domains\n                        }\n                        cookie.domain = domain;\n                        break;\n\n                    case 'max-age':\n                        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                        break;\n\n                    case 'secure':\n                        cookie.secure = true;\n                        break;\n\n                    case 'httponly':\n                        cookie.httponly = true;\n                        break;\n\n                    default:\n                        if (!cookie.name) {\n                            cookie.name = key;\n                            cookie.value = value;\n                        }\n                }\n            });\n\n        return cookie;\n    }\n\n    /**\n     * Checks if a cookie object is valid for a specified URL\n     *\n     * @param {Object} cookie Cookie object\n     * @param {String} url URL to check for\n     * @returns {Boolean} true if cookie is valid for specifiec URL\n     */\n    match(cookie, url) {\n        let urlparts = urllib.parse(url || '');\n\n        // check if hostname matches\n        // .foo.com also matches subdomains, foo.com does not\n        if (\n            urlparts.hostname !== cookie.domain &&\n            (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)\n        ) {\n            return false;\n        }\n\n        // check if path matches\n        let path = this.getPath(urlparts.pathname);\n        if (path.substr(0, cookie.path.length) !== cookie.path) {\n            return false;\n        }\n\n        // check secure argument\n        if (cookie.secure && urlparts.protocol !== 'https:') {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Adds (or updates/removes if needed) a cookie object to the cookie storage\n     *\n     * @param {Object} cookie Cookie value to be stored\n     */\n    add(cookie) {\n        let i;\n        let len;\n\n        // nothing to do here\n        if (!cookie || !cookie.name) {\n            return false;\n        }\n\n        // overwrite if has same params\n        for (i = 0, len = this.cookies.length; i < len; i++) {\n            if (this.compare(this.cookies[i], cookie)) {\n                // check if the cookie needs to be removed instead\n                if (this.isExpired(cookie)) {\n                    this.cookies.splice(i, 1); // remove expired/unset cookie\n                    return false;\n                }\n\n                this.cookies[i] = cookie;\n                return true;\n            }\n        }\n\n        // add as new if not already expired\n        if (!this.isExpired(cookie)) {\n            this.cookies.push(cookie);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if two cookie objects are the same\n     *\n     * @param {Object} a Cookie to check against\n     * @param {Object} b Cookie to check against\n     * @returns {Boolean} True, if the cookies are the same\n     */\n    compare(a, b) {\n        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n    }\n\n    /**\n     * Checks if a cookie is expired\n     *\n     * @param {Object} cookie Cookie object to check against\n     * @returns {Boolean} True, if the cookie is expired\n     */\n    isExpired(cookie) {\n        return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n    }\n\n    /**\n     * Returns normalized cookie path for an URL path argument\n     *\n     * @param {String} pathname\n     * @returns {String} Normalized path\n     */\n    getPath(pathname) {\n        let path = (pathname || '/').split('/');\n        path.pop(); // remove filename part\n        path = path.join('/').trim();\n\n        // ensure path prefix /\n        if (path.charAt(0) !== '/') {\n            path = '/' + path;\n        }\n\n        // ensure path suffix /\n        if (path.substr(-1) !== '/') {\n            path += '/';\n        }\n\n        return path;\n    }\n}\n\nmodule.exports = Cookies;\n"]},"metadata":{},"sourceType":"script"}