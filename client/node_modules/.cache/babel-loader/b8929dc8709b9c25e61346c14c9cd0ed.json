{"ast":null,"code":"'use strict';\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst urllib = require('url');\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\n\n\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n  let proxy = urllib.parse(proxyUrl); // create a socket connection to the proxy server\n\n  let options;\n  let connect;\n  let socket;\n  options = {\n    host: proxy.hostname,\n    port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n  };\n\n  if (proxy.protocol === 'https:') {\n    // we can use untrusted proxies as long as we verify actual SMTP certificates\n    options.rejectUnauthorized = false;\n    connect = tls.connect.bind(tls);\n  } else {\n    connect = net.connect.bind(net);\n  } // Error harness for initial connection. Once connection is established, the responsibility\n  // to handle errors is passed to whoever uses this socket\n\n\n  let finished = false;\n\n  let tempSocketErr = function (err) {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n\n    try {\n      socket.destroy();\n    } catch (E) {// ignore\n    }\n\n    callback(err);\n  };\n\n  socket = connect(options, () => {\n    if (finished) {\n      return;\n    }\n\n    let reqHeaders = {\n      Host: destinationHost + ':' + destinationPort,\n      Connection: 'close'\n    };\n\n    if (proxy.auth) {\n      reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n    }\n\n    socket.write( // HTTP method\n    'CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\\r\\n' + // HTTP request headers\n    Object.keys(reqHeaders).map(key => key + ': ' + reqHeaders[key]).join('\\r\\n') + // End request\n    '\\r\\n\\r\\n');\n    let headers = '';\n\n    let onSocketData = chunk => {\n      let match;\n      let remainder;\n\n      if (finished) {\n        return;\n      }\n\n      headers += chunk.toString('binary');\n\n      if (match = headers.match(/\\r\\n\\r\\n/)) {\n        socket.removeListener('data', onSocketData);\n        remainder = headers.substr(match.index + match[0].length);\n        headers = headers.substr(0, match.index);\n\n        if (remainder) {\n          socket.unshift(Buffer.from(remainder, 'binary'));\n        } // proxy connection is now established\n\n\n        finished = true; // check response code\n\n        match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n\n        if (!match || (match[1] || '').charAt(0) !== '2') {\n          try {\n            socket.destroy();\n          } catch (E) {// ignore\n          }\n\n          return callback(new Error('Invalid response from proxy' + (match && ': ' + match[1] || '')));\n        }\n\n        socket.removeListener('error', tempSocketErr);\n        return callback(null, socket);\n      }\n    };\n\n    socket.on('data', onSocketData);\n  });\n  socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;","map":{"version":3,"sources":["C:/Users/tanka/Desktop/ESC/Project/SingHealthApp/singhealth2.0/node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js"],"names":["net","require","tls","urllib","httpProxyClient","proxyUrl","destinationPort","destinationHost","callback","proxy","parse","options","connect","socket","host","hostname","port","Number","protocol","rejectUnauthorized","bind","finished","tempSocketErr","err","destroy","E","reqHeaders","Host","Connection","auth","Buffer","from","toString","write","Object","keys","map","key","join","headers","onSocketData","chunk","match","remainder","removeListener","substr","index","length","unshift","charAt","Error","on","once","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // create a socket connection to the proxy server\n    let options;\n    let connect;\n    let socket;\n\n    options = {\n        host: proxy.hostname,\n        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n    };\n\n    if (proxy.protocol === 'https:') {\n        // we can use untrusted proxies as long as we verify actual SMTP certificates\n        options.rejectUnauthorized = false;\n        connect = tls.connect.bind(tls);\n    } else {\n        connect = net.connect.bind(net);\n    }\n\n    // Error harness for initial connection. Once connection is established, the responsibility\n    // to handle errors is passed to whoever uses this socket\n    let finished = false;\n    let tempSocketErr = function (err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        try {\n            socket.destroy();\n        } catch (E) {\n            // ignore\n        }\n        callback(err);\n    };\n\n    socket = connect(options, () => {\n        if (finished) {\n            return;\n        }\n\n        let reqHeaders = {\n            Host: destinationHost + ':' + destinationPort,\n            Connection: 'close'\n        };\n        if (proxy.auth) {\n            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n        }\n\n        socket.write(\n            // HTTP method\n            'CONNECT ' +\n                destinationHost +\n                ':' +\n                destinationPort +\n                ' HTTP/1.1\\r\\n' +\n                // HTTP request headers\n                Object.keys(reqHeaders)\n                    .map(key => key + ': ' + reqHeaders[key])\n                    .join('\\r\\n') +\n                // End request\n                '\\r\\n\\r\\n'\n        );\n\n        let headers = '';\n        let onSocketData = chunk => {\n            let match;\n            let remainder;\n\n            if (finished) {\n                return;\n            }\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n\n                // proxy connection is now established\n                finished = true;\n\n                // check response code\n                match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n                if (!match || (match[1] || '').charAt(0) !== '2') {\n                    try {\n                        socket.destroy();\n                    } catch (E) {\n                        // ignore\n                    }\n                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));\n                }\n\n                socket.removeListener('error', tempSocketErr);\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;\n"]},"metadata":{},"sourceType":"script"}