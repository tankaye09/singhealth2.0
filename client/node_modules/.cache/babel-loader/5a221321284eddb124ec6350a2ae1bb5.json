{"ast":null,"code":"'use strict';\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\n\nfunction _handleAddress(tokens) {\n  let token;\n  let isGroup = false;\n  let state = 'text';\n  let address;\n  let addresses = [];\n  let data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: []\n  };\n  let i;\n  let len; // Filter out <addresses>, (comments) and regular text\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    token = tokens[i];\n\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          break;\n\n        case '(':\n          state = 'comment';\n          break;\n\n        case ':':\n          state = 'group';\n          isGroup = true;\n          break;\n\n        default:\n          state = 'text';\n      }\n    } else if (token.value) {\n      if (state === 'address') {\n        // handle use case where unquoted name includes a \"<\"\n        // Apple Mail truncates everything between an unexpected < and an address\n        // and so will we\n        token.value = token.value.replace(/^[^<]*<\\s*/, '');\n      }\n\n      data[state].push(token.value);\n    }\n  } // If there is no text but a comment, replace the two\n\n\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment;\n    data.comment = [];\n  }\n\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ');\n    addresses.push({\n      name: data.text || address && address.name,\n      group: data.group.length ? addressparser(data.group.join(',')) : []\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (i = data.text.length - 1; i >= 0; i--) {\n        if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(i, 1);\n          break;\n        }\n      }\n\n      let _regexHandler = function (address) {\n        if (!data.address.length) {\n          data.address = [address.trim()];\n          return ' ';\n        } else {\n          return address;\n        }\n      }; // still no address\n\n\n      if (!data.address.length) {\n        for (i = data.text.length - 1; i >= 0; i--) {\n          // fixed the regex to parse email address correctly when email address has more than one @\n          data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n\n          if (data.address.length) {\n            break;\n          }\n        }\n      }\n    } // If there's still is no text but a comment exixts, replace the two\n\n\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment;\n      data.comment = [];\n    } // Keep only the first address occurence, push others to regular text\n\n\n    if (data.address.length > 1) {\n      data.text = data.text.concat(data.address.splice(1));\n    } // Join values with spaces\n\n\n    data.text = data.text.join(' ');\n    data.address = data.address.join(' ');\n\n    if (!data.address && isGroup) {\n      return [];\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      };\n\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = '';\n        } else {\n          address.address = '';\n        }\n      }\n\n      addresses.push(address);\n    }\n  }\n\n  return addresses;\n}\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\n\n\nclass Tokenizer {\n  constructor(str) {\n    this.str = (str || '').toString();\n    this.operatorCurrent = '';\n    this.operatorExpecting = '';\n    this.node = null;\n    this.escaped = false;\n    this.list = [];\n    /**\n     * Operator tokens and which tokens are expected to end the sequence\n     */\n\n    this.operators = {\n      '\"': '\"',\n      '(': ')',\n      '<': '>',\n      ',': '',\n      ':': ';',\n      // Semicolons are not a legal delimiter per the RFC2822 grammar other\n      // than for terminating a group, but they are also not valid for any\n      // other use in this context.  Given that some mail clients have\n      // historically allowed the semicolon as a delimiter equivalent to the\n      // comma in their UI, it makes sense to treat them the same as a comma\n      // when used outside of a group.\n      ';': ''\n    };\n  }\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n\n\n  tokenize() {\n    let chr,\n        list = [];\n\n    for (let i = 0, len = this.str.length; i < len; i++) {\n      chr = this.str.charAt(i);\n      this.checkChar(chr);\n    }\n\n    this.list.forEach(node => {\n      node.value = (node.value || '').toString().trim();\n\n      if (node.value) {\n        list.push(node);\n      }\n    });\n    return list;\n  }\n  /**\n   * Checks if a character is an operator or text and acts accordingly\n   *\n   * @param {String} chr Character from the address field\n   */\n\n\n  checkChar(chr) {\n    if (this.escaped) {// ignore next condition blocks\n    } else if (chr === this.operatorExpecting) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      };\n      this.list.push(this.node);\n      this.node = null;\n      this.operatorExpecting = '';\n      this.escaped = false;\n      return;\n    } else if (!this.operatorExpecting && chr in this.operators) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      };\n      this.list.push(this.node);\n      this.node = null;\n      this.operatorExpecting = this.operators[chr];\n      this.escaped = false;\n      return;\n    } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n      this.escaped = true;\n      return;\n    }\n\n    if (!this.node) {\n      this.node = {\n        type: 'text',\n        value: ''\n      };\n      this.list.push(this.node);\n    }\n\n    if (chr === '\\n') {\n      // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n      // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n      chr = ' ';\n    }\n\n    if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n      // skip command bytes\n      this.node.value += chr;\n    }\n\n    this.escaped = false;\n  }\n\n}\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\n\n\nfunction addressparser(str, options) {\n  options = options || {};\n  let tokenizer = new Tokenizer(str);\n  let tokens = tokenizer.tokenize();\n  let addresses = [];\n  let address = [];\n  let parsedAddresses = [];\n  tokens.forEach(token => {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address);\n      }\n\n      address = [];\n    } else {\n      address.push(token);\n    }\n  });\n\n  if (address.length) {\n    addresses.push(address);\n  }\n\n  addresses.forEach(address => {\n    address = _handleAddress(address);\n\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address);\n    }\n  });\n\n  if (options.flatten) {\n    let addresses = [];\n\n    let walkAddressList = list => {\n      list.forEach(address => {\n        if (address.group) {\n          return walkAddressList(address.group);\n        } else {\n          addresses.push(address);\n        }\n      });\n    };\n\n    walkAddressList(parsedAddresses);\n    return addresses;\n  }\n\n  return parsedAddresses;\n} // expose to the world\n\n\nmodule.exports = addressparser;","map":{"version":3,"sources":["C:/Users/tanka/Desktop/ESC/Project/SingHealthApp/singhealth2.0/node_modules/nodemailer/lib/addressparser/index.js"],"names":["_handleAddress","tokens","token","isGroup","state","address","addresses","data","comment","group","text","i","len","length","type","value","replace","push","join","name","addressparser","match","splice","_regexHandler","trim","concat","Tokenizer","constructor","str","toString","operatorCurrent","operatorExpecting","node","escaped","list","operators","tokenize","chr","charAt","checkChar","forEach","includes","charCodeAt","options","tokenizer","parsedAddresses","flatten","walkAddressList","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens) {\n    let token;\n    let isGroup = false;\n    let state = 'text';\n    let address;\n    let addresses = [];\n    let data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: []\n    };\n    let i;\n    let len;\n\n    // Filter out <addresses>, (comments) and regular text\n    for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    break;\n                case '(':\n                    state = 'comment';\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    break;\n                default:\n                    state = 'text';\n            }\n        } else if (token.value) {\n            if (state === 'address') {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, '');\n            }\n            data[state].push(token.value);\n        }\n    }\n\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(' ');\n        addresses.push({\n            name: data.text || (address && address.name),\n            group: data.group.length ? addressparser(data.group.join(',')) : []\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for (i = data.text.length - 1; i >= 0; i--) {\n                if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    break;\n                }\n            }\n\n            let _regexHandler = function (address) {\n                if (!data.address.length) {\n                    data.address = [address.trim()];\n                    return ' ';\n                } else {\n                    return address;\n                }\n            };\n\n            // still no address\n            if (!data.address.length) {\n                for (i = data.text.length - 1; i >= 0; i--) {\n                    // fixed the regex to parse email address correctly when email address has more than one @\n                    data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                    if (data.address.length) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n\n        // Join values with spaces\n        data.text = data.text.join(' ');\n        data.address = data.address.join(' ');\n\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || '',\n                name: data.text || data.address || ''\n            };\n\n            if (address.address === address.name) {\n                if ((address.address || '').match(/@/)) {\n                    address.name = '';\n                } else {\n                    address.address = '';\n                }\n            }\n\n            addresses.push(address);\n        }\n    }\n\n    return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n    constructor(str) {\n        this.str = (str || '').toString();\n        this.operatorCurrent = '';\n        this.operatorExpecting = '';\n        this.node = null;\n        this.escaped = false;\n\n        this.list = [];\n        /**\n         * Operator tokens and which tokens are expected to end the sequence\n         */\n        this.operators = {\n            '\"': '\"',\n            '(': ')',\n            '<': '>',\n            ',': '',\n            ':': ';',\n            // Semicolons are not a legal delimiter per the RFC2822 grammar other\n            // than for terminating a group, but they are also not valid for any\n            // other use in this context.  Given that some mail clients have\n            // historically allowed the semicolon as a delimiter equivalent to the\n            // comma in their UI, it makes sense to treat them the same as a comma\n            // when used outside of a group.\n            ';': ''\n        };\n    }\n\n    /**\n     * Tokenizes the original input string\n     *\n     * @return {Array} An array of operator|text tokens\n     */\n    tokenize() {\n        let chr,\n            list = [];\n        for (let i = 0, len = this.str.length; i < len; i++) {\n            chr = this.str.charAt(i);\n            this.checkChar(chr);\n        }\n\n        this.list.forEach(node => {\n            node.value = (node.value || '').toString().trim();\n            if (node.value) {\n                list.push(node);\n            }\n        });\n\n        return list;\n    }\n\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n    checkChar(chr) {\n        if (this.escaped) {\n            // ignore next condition blocks\n        } else if (chr === this.operatorExpecting) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = '';\n            this.escaped = false;\n            return;\n        } else if (!this.operatorExpecting && chr in this.operators) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = this.operators[chr];\n            this.escaped = false;\n            return;\n        } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n            this.escaped = true;\n            return;\n        }\n\n        if (!this.node) {\n            this.node = {\n                type: 'text',\n                value: ''\n            };\n            this.list.push(this.node);\n        }\n\n        if (chr === '\\n') {\n            // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n            // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n            chr = ' ';\n        }\n\n        if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n            // skip command bytes\n            this.node.value += chr;\n        }\n\n        this.escaped = false;\n    }\n}\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nfunction addressparser(str, options) {\n    options = options || {};\n\n    let tokenizer = new Tokenizer(str);\n    let tokens = tokenizer.tokenize();\n\n    let addresses = [];\n    let address = [];\n    let parsedAddresses = [];\n\n    tokens.forEach(token => {\n        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n\n    if (address.length) {\n        addresses.push(address);\n    }\n\n    addresses.forEach(address => {\n        address = _handleAddress(address);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n\n    if (options.flatten) {\n        let addresses = [];\n        let walkAddressList = list => {\n            list.forEach(address => {\n                if (address.group) {\n                    return walkAddressList(address.group);\n                } else {\n                    addresses.push(address);\n                }\n            });\n        };\n        walkAddressList(parsedAddresses);\n        return addresses;\n    }\n\n    return parsedAddresses;\n}\n\n// expose to the world\nmodule.exports = addressparser;\n"]},"metadata":{},"sourceType":"script"}