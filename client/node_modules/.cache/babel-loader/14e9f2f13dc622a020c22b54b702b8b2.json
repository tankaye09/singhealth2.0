{"ast":null,"code":"'use strict'; // streams through a message body and calculates relaxed body hash\n\nconst Transform = require('stream').Transform;\n\nconst crypto = require('crypto');\n\nclass RelaxedBody extends Transform {\n  constructor(options) {\n    super();\n    options = options || {};\n    this.chunkBuffer = [];\n    this.chunkBufferLen = 0;\n    this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');\n    this.remainder = '';\n    this.byteLength = 0;\n    this.debug = options.debug;\n    this._debugBody = options.debug ? [] : false;\n  }\n\n  updateHash(chunk) {\n    let bodyStr; // find next remainder\n\n    let nextRemainder = ''; // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line\n    // If we get another chunk that does not match this description then we can restore the previously processed data\n\n    let state = 'file';\n\n    for (let i = chunk.length - 1; i >= 0; i--) {\n      let c = chunk[i];\n\n      if (state === 'file' && (c === 0x0a || c === 0x0d)) {// do nothing, found \\n or \\r at the end of chunk, stil end of file\n      } else if (state === 'file' && (c === 0x09 || c === 0x20)) {\n        // switch to line ending mode, this is the last non-empty line\n        state = 'line';\n      } else if (state === 'line' && (c === 0x09 || c === 0x20)) {// do nothing, found ' ' or \\t at the end of line, keep processing the last non-empty line\n      } else if (state === 'file' || state === 'line') {\n        // non line/file ending character found, switch to body mode\n        state = 'body';\n\n        if (i === chunk.length - 1) {\n          // final char is not part of line end or file end, so do nothing\n          break;\n        }\n      }\n\n      if (i === 0) {\n        // reached to the beginning of the chunk, check if it is still about the ending\n        // and if the remainder also matches\n        if (state === 'file' && (!this.remainder || /[\\r\\n]$/.test(this.remainder)) || state === 'line' && (!this.remainder || /[ \\t]$/.test(this.remainder))) {\n          // keep everything\n          this.remainder += chunk.toString('binary');\n          return;\n        } else if (state === 'line' || state === 'file') {\n          // process existing remainder as normal line but store the current chunk\n          nextRemainder = chunk.toString('binary');\n          chunk = false;\n          break;\n        }\n      }\n\n      if (state !== 'body') {\n        continue;\n      } // reached first non ending byte\n\n\n      nextRemainder = chunk.slice(i + 1).toString('binary');\n      chunk = chunk.slice(0, i + 1);\n      break;\n    }\n\n    let needsFixing = !!this.remainder;\n\n    if (chunk && !needsFixing) {\n      // check if we even need to change anything\n      for (let i = 0, len = chunk.length; i < len; i++) {\n        if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {\n          // missing \\r before \\n\n          needsFixing = true;\n          break;\n        } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {\n          // trailing WSP found\n          needsFixing = true;\n          break;\n        } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {\n          // multiple spaces found, needs to be replaced with just one\n          needsFixing = true;\n          break;\n        } else if (chunk[i] === 0x09) {\n          // TAB found, needs to be replaced with a space\n          needsFixing = true;\n          break;\n        }\n      }\n    }\n\n    if (needsFixing) {\n      bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');\n      this.remainder = nextRemainder;\n      bodyStr = bodyStr.replace(/\\r?\\n/g, '\\n') // use js line endings\n      .replace(/[ \\t]*$/gm, '') // remove line endings, rtrim\n      .replace(/[ \\t]+/gm, ' ') // single spaces\n      .replace(/\\n/g, '\\r\\n'); // restore rfc822 line endings\n\n      chunk = Buffer.from(bodyStr, 'binary');\n    } else if (nextRemainder) {\n      this.remainder = nextRemainder;\n    }\n\n    if (this.debug) {\n      this._debugBody.push(chunk);\n    }\n\n    this.bodyHash.update(chunk);\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (!chunk || !chunk.length) {\n      return callback();\n    }\n\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.updateHash(chunk);\n    this.byteLength += chunk.length;\n    this.push(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    // generate final hash and emit it\n    if (/[\\r\\n]$/.test(this.remainder) && this.byteLength > 2) {\n      // add terminating line end\n      this.bodyHash.update(Buffer.from('\\r\\n'));\n    }\n\n    if (!this.byteLength) {\n      // emit empty line buffer to keep the stream flowing\n      this.push(Buffer.from('\\r\\n')); // this.bodyHash.update(Buffer.from('\\r\\n'));\n    }\n\n    this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);\n    callback();\n  }\n\n}\n\nmodule.exports = RelaxedBody;","map":{"version":3,"sources":["C:/Users/tanka/Desktop/ESC/Project/SingHealthApp/singhealth2.0/node_modules/nodemailer/lib/dkim/relaxed-body.js"],"names":["Transform","require","crypto","RelaxedBody","constructor","options","chunkBuffer","chunkBufferLen","bodyHash","createHash","hashAlgo","remainder","byteLength","debug","_debugBody","updateHash","chunk","bodyStr","nextRemainder","state","i","length","c","test","toString","slice","needsFixing","len","replace","Buffer","from","push","update","_transform","encoding","callback","_flush","emit","digest","concat","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// streams through a message body and calculates relaxed body hash\n\nconst Transform = require('stream').Transform;\nconst crypto = require('crypto');\n\nclass RelaxedBody extends Transform {\n    constructor(options) {\n        super();\n        options = options || {};\n        this.chunkBuffer = [];\n        this.chunkBufferLen = 0;\n        this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');\n        this.remainder = '';\n        this.byteLength = 0;\n\n        this.debug = options.debug;\n        this._debugBody = options.debug ? [] : false;\n    }\n\n    updateHash(chunk) {\n        let bodyStr;\n\n        // find next remainder\n        let nextRemainder = '';\n\n        // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line\n        // If we get another chunk that does not match this description then we can restore the previously processed data\n        let state = 'file';\n        for (let i = chunk.length - 1; i >= 0; i--) {\n            let c = chunk[i];\n\n            if (state === 'file' && (c === 0x0a || c === 0x0d)) {\n                // do nothing, found \\n or \\r at the end of chunk, stil end of file\n            } else if (state === 'file' && (c === 0x09 || c === 0x20)) {\n                // switch to line ending mode, this is the last non-empty line\n                state = 'line';\n            } else if (state === 'line' && (c === 0x09 || c === 0x20)) {\n                // do nothing, found ' ' or \\t at the end of line, keep processing the last non-empty line\n            } else if (state === 'file' || state === 'line') {\n                // non line/file ending character found, switch to body mode\n                state = 'body';\n                if (i === chunk.length - 1) {\n                    // final char is not part of line end or file end, so do nothing\n                    break;\n                }\n            }\n\n            if (i === 0) {\n                // reached to the beginning of the chunk, check if it is still about the ending\n                // and if the remainder also matches\n                if (\n                    (state === 'file' && (!this.remainder || /[\\r\\n]$/.test(this.remainder))) ||\n                    (state === 'line' && (!this.remainder || /[ \\t]$/.test(this.remainder)))\n                ) {\n                    // keep everything\n                    this.remainder += chunk.toString('binary');\n                    return;\n                } else if (state === 'line' || state === 'file') {\n                    // process existing remainder as normal line but store the current chunk\n                    nextRemainder = chunk.toString('binary');\n                    chunk = false;\n                    break;\n                }\n            }\n\n            if (state !== 'body') {\n                continue;\n            }\n\n            // reached first non ending byte\n            nextRemainder = chunk.slice(i + 1).toString('binary');\n            chunk = chunk.slice(0, i + 1);\n            break;\n        }\n\n        let needsFixing = !!this.remainder;\n        if (chunk && !needsFixing) {\n            // check if we even need to change anything\n            for (let i = 0, len = chunk.length; i < len; i++) {\n                if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {\n                    // missing \\r before \\n\n                    needsFixing = true;\n                    break;\n                } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {\n                    // trailing WSP found\n                    needsFixing = true;\n                    break;\n                } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {\n                    // multiple spaces found, needs to be replaced with just one\n                    needsFixing = true;\n                    break;\n                } else if (chunk[i] === 0x09) {\n                    // TAB found, needs to be replaced with a space\n                    needsFixing = true;\n                    break;\n                }\n            }\n        }\n\n        if (needsFixing) {\n            bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');\n            this.remainder = nextRemainder;\n            bodyStr = bodyStr\n                .replace(/\\r?\\n/g, '\\n') // use js line endings\n                .replace(/[ \\t]*$/gm, '') // remove line endings, rtrim\n                .replace(/[ \\t]+/gm, ' ') // single spaces\n                .replace(/\\n/g, '\\r\\n'); // restore rfc822 line endings\n            chunk = Buffer.from(bodyStr, 'binary');\n        } else if (nextRemainder) {\n            this.remainder = nextRemainder;\n        }\n\n        if (this.debug) {\n            this._debugBody.push(chunk);\n        }\n        this.bodyHash.update(chunk);\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.updateHash(chunk);\n\n        this.byteLength += chunk.length;\n        this.push(chunk);\n        callback();\n    }\n\n    _flush(callback) {\n        // generate final hash and emit it\n        if (/[\\r\\n]$/.test(this.remainder) && this.byteLength > 2) {\n            // add terminating line end\n            this.bodyHash.update(Buffer.from('\\r\\n'));\n        }\n        if (!this.byteLength) {\n            // emit empty line buffer to keep the stream flowing\n            this.push(Buffer.from('\\r\\n'));\n            // this.bodyHash.update(Buffer.from('\\r\\n'));\n        }\n\n        this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);\n        callback();\n    }\n}\n\nmodule.exports = RelaxedBody;\n"]},"metadata":{},"sourceType":"script"}